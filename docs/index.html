<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-02-14 Sun 00:59 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Lowest eigenvalue with Variational Quantum Eigensolver</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Soham Pal" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Lowest eigenvalue with Variational Quantum Eigensolver</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org04ac827">Introduction</a></li>
<li><a href="#org8455bd0">Algorithm</a></li>
<li><a href="#org771a52a">Ansatz</a></li>
<li><a href="#org70a8d80">Pauli Decomposition</a></li>
<li><a href="#orgda403f4">Optimization</a></li>
<li><a href="#org2f3130d">Simulation</a></li>
<li><a href="#org6f8ada5">Visualization</a></li>
<li><a href="#org41708be">Conclusion</a></li>
</ul>
</div>
</div>

<div id="outline-container-org04ac827" class="outline-2">
<h2 id="org04ac827">Introduction</h2>
<div class="outline-text-2" id="text-org04ac827">
<p>
Variational quantum eigensolver (VQE)<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> is a hybrid quantum-classical
algorithm that can be used on NISQ devices to find the ground states of various
quantum mechanical systems, most notably used in quantum chemistry<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup> and
nuclear physics<sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup>. Here we will see a demonstration of the variational
quantum eigensolver with the Hamiltonian
</p>
\begin{align}
H = \begin{bmatrix}
  1 & 0 & 0 & 0\\
  0 & 0 & -1 & 0\\
  0 & -1 & 0 & 0\\
  0 & 0 & 0 & 1
  \end{bmatrix},
\end{align}
<p>
whose eigenvalues can be calculated easily on a classical computer:
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #51afef;">import</span> numpy <span style="color: #51afef;">as</span> np

<span style="color: #dcaeea;">H</span> = np.zeros(shape=(<span style="color: #da8548; font-weight: bold;">4</span>, <span style="color: #da8548; font-weight: bold;">4</span>))
<span style="color: #dcaeea;">H</span>[<span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>] = <span style="color: #dcaeea;">H</span>[<span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">3</span>] = <span style="color: #da8548; font-weight: bold;">1</span>
<span style="color: #dcaeea;">H</span>[<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">2</span>] = <span style="color: #dcaeea;">H</span>[<span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">1</span>] = -<span style="color: #da8548; font-weight: bold;">1</span>

<span style="color: #51afef;">print</span>(<span style="color: #98be65;">"Hamiltonian:"</span>)
<span style="color: #51afef;">print</span>(H)

<span style="color: #51afef;">print</span>(f<span style="color: #98be65;">"Eigenvalues: {np.linalg.eigvals(H)}"</span>)
</pre>
</div>

<pre class="example">
Hamiltonian:
[[ 1.  0.  0.  0.]
 [ 0.  0. -1.  0.]
 [ 0. -1.  0.  0.]
 [ 0.  0.  0.  1.]]
Eigenvalues: [ 1. -1.  1.  1.]
</pre>


<p>
The minimum eigenvalue is \(-1\). While the eigenvalues for this Hamiltonian could
be calculated easily on a classical computer, this is not generally true for
Hamiltonians of interest in physics and chemistry. Hence the need for algorithms
like VQE.
</p>
</div>
</div>

<div id="outline-container-org8455bd0" class="outline-2">
<h2 id="org8455bd0">Algorithm</h2>
<div class="outline-text-2" id="text-org8455bd0">
<p>
The VQE algorithm can be broken down in to the following steps:
</p>

<ol class="org-ol">
<li>Let \(n = 0\). Design a quantum circuit, controlled by a set of parameters
\({θ_i}\), and prepare the initial state \(|ψ(θ_i^n)〉\) with this
circuit. This is known as the ansatz.</li>

<li>Define the objective function \(f({θ_i^n}) = ⟨ψ({θ_i^n})|H|ψ({θ_i^n})⟩\),
that is the expectation value of the Hamiltonian with respect the ansatz.</li>

<li>Repeat until optimization is completed:
<ol class="org-ol">
<li>Calculate \(f({θ_i^n})\) on the quantum computer.</li>
<li>Feed \(f({θ_i^n})\) to a classical minimization algorithm, and allow it to
determine \({θ_i^{n+1}}\).</li>
</ol></li>
</ol>
</div>
</div>

<div id="outline-container-org771a52a" class="outline-2">
<h2 id="org771a52a">Ansatz</h2>
<div class="outline-text-2" id="text-org771a52a">
<p>
There are two things that the user can choose in this algorithm: the initial
state, and the classical minimization algorithm. Of this, it turns out, the
initial state (ansatz) is the most important. The selection of a particular
ansatz are usually determined by the choice of the hardware, and the features of
the problem, such as the symmetries of the Hamiltonian. For computation on NISQ
devices, the hardware is usually the dominating factor. We will consider two
ansatzes for this demonstration. The first is parameterized by RY and RZ
gates. This is a special case of the hardware efficient ansatz described in the
paper by Kandala <i>et al.</i>.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #51afef;">from</span> vqe.vqe <span style="color: #51afef;">import</span> RYRZAnsatz, RXAnsatz
<span style="color: #51afef;">import</span> matplotlib.pyplot <span style="color: #51afef;">as</span> plt

<span style="color: #dcaeea;">fig</span>, <span style="color: #dcaeea;">ax</span> = plt.subplots(figsize=(<span style="color: #da8548; font-weight: bold;">6</span>, <span style="color: #da8548; font-weight: bold;">4</span>))
RYRZAnsatz(reps=<span style="color: #da8548; font-weight: bold;">3</span>, barriers=<span style="color: #a9a1e1;">True</span>).draw(<span style="color: #98be65;">"mpl"</span>, ax=ax)
fig.suptitle(<span style="color: #98be65;">"RYRZ ansatz with 3 repetitions"</span>)
fig.savefig(<span style="color: #98be65;">"static/images/ryrz_ansatz.png"</span>, dpi=<span style="color: #da8548; font-weight: bold;">90</span>, bbox_inches=<span style="color: #98be65;">"tight"</span>)
plt.close()
</pre>
</div>


<div id="org8b5f137" class="figure">
<p><img src="static/images/ryrz_ansatz.png" alt="ryrz_ansatz.png" />
</p>
</div>

<p>
The second ansatz is parameterized by RX gates.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #dcaeea;">fig</span>, <span style="color: #dcaeea;">ax</span> = plt.subplots(figsize=(<span style="color: #da8548; font-weight: bold;">6</span>, <span style="color: #da8548; font-weight: bold;">4</span>))
RXAnsatz(reps=<span style="color: #da8548; font-weight: bold;">3</span>, barriers=<span style="color: #a9a1e1;">True</span>).draw(<span style="color: #98be65;">"mpl"</span>, ax=ax)
fig.suptitle(<span style="color: #98be65;">"RX ansatz with 3 repetitions"</span>)
fig.savefig(<span style="color: #98be65;">"static/images/rx_ansatz.png"</span>, dpi=<span style="color: #da8548; font-weight: bold;">90</span>, bbox_inches=<span style="color: #98be65;">"tight"</span>)
plt.close()
</pre>
</div>


<div id="org0b63cdf" class="figure">
<p><img src="static/images/rx_ansatz.png" alt="rx_ansatz.png" />
</p>
</div>

<p>
These were the multi-layer versions of the ansatzes. In the single-layer
versions the blocks just appear once.
</p>
</div>
</div>

<div id="outline-container-org70a8d80" class="outline-2">
<h2 id="org70a8d80">Pauli Decomposition</h2>
<div class="outline-text-2" id="text-org70a8d80">
<p>
One caveat of using VQE is that in general it is not easy to calculate the
expectation value of the Hamiltonian. However if the Hamiltonian can be
expressed as a linear sum of tensor products of the Pauli matrices \((I, X, Y,
Z)\), then we can easily calculate the expectation value of the
Hamiltonian. Tensor products of Pauli matrices, \(\{\{I, X, Y, Z\}^{⊗n}\}\),
form an orthogonal basis for the vector space of \(2^n × 2^n\) Hermitian
matrices. Thus any \(2^n × 2^n\) Hermitian matrix can be expressed as a linear
sum of tensor products of Pauli matrices. For example, for n = 1, consider the
Hermitian matrix
</p>
\begin{align}
A = \begin{bmatrix} 2 & 1 \\ 1 & -3 \end{bmatrix}.
\end{align}
<p>
This matrix can be expressed as \(A = -\tfrac{1}{2}I + X + \tfrac{5}{2}Z\). In
general for a \(2^n × 2^n\) Hermitian matrix A, the coefficients of expansion in
the basis of tensor products of Pauli matrices is given by
</p>
\begin{align}
a_{i_1 i_2 ⋯ i_n}
= \frac{1}{2^n} \mathrm{Tr}((σ_{i_1} ⊗ σ_{i_2} ⊗ ⋯ σ_{i_n})A),
\end{align}
<p>
where \(σ_{i_j} ∈ \{I, X, Y, Z\}\), and \(\mathrm{Tr}\) represents the trace of
a matrix<sup><a id="fnr.4" class="footref" href="#fn.4">4</a></sup>. The factor of \(\frac{1}{2^n}\) is to normalize
the Pauli matrices. The function <code>pauli_decomposition</code> in
<code>vqe/utils.py</code> does this decomposition for any \(2^n × 2^n\) Hermitian
matrix. Here is the decomposition of our Hamiltonian \(H\):
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #51afef;">from</span> vqe.utils <span style="color: #51afef;">import</span> pauli_decomposition

pauli_decomposition(H)
</pre>
</div>

<pre class="example">
defaultdict(int, {'II': 0.5, 'XX': -0.5, 'YY': -0.5, 'ZZ': 0.5})
</pre>


<p>
We can express our Hamiltonian as \(H = \tfrac{1}{2}(II + ZZ - XX - YY)\). Thus
\(〈H〉 = \tfrac{1}{2}(〈II〉 + 〈ZZ〉 - 〈XX〉 - 〈YY〉)\), where \(〈O〉 =
〈ψ|O|ψ〉\) is the expectation value of the observable \(O\). Since the
expectation value of \(II\) is always \(1\), therefore this boils down to
calculating the expectation values of \(ZZ\), \(XX\), and \(YY\), and then doing
the weighted sum of all the four expectation values. Tensor products of Pauli
matrices have only two eigenvalues, \(±1\). The expectation value of a tensor
product of Pauli matrices can be calculated on a quantum computer as
\(\tfrac{(N_+ - N_-)}{N}\), where \(N_±\) is the number of measured eigenvectors
corresponding to the eigenvalue \(±1\) and \(N\) is the total number of
measurements<sup><a id="fnr.5" class="footref" href="#fn.5">5</a></sup>. The function <code>energy</code> in <code>vqe/vqe.py</code> computes the
expectation value of any Hamiltonian which has a Pauli decomposition with
respect to any given ansatz.
</p>
</div>
</div>

<div id="outline-container-orgda403f4" class="outline-2">
<h2 id="orgda403f4">Optimization</h2>
<div class="outline-text-2" id="text-orgda403f4">
<p>
Any classical optimization algorithm can be used in VQE, with varying degrees of
success. Gradient-free methods like COBYLA, Nelson-Mead, SPSA etc. are the
preferred methods for these problems since it will be difficult to calculate the
derivative of the objective function. For problems like VQE, SPSA or
Simultaneous Perturbation Stochastic Approximation<sup><a id="fnr.6" class="footref" href="#fn.6">6</a></sup> might be the most
suitable, since it scales well to large problems (unlike COBYLA), and accounts
for noise which is ubiquitous on a NISQ device. The basic SPSA algorithm is as
follows:
</p>

<ol class="org-ol">
<li>Start with an initial guess for the optimization parameters \(θ = \{θ_i\}\).</li>

<li><p>
For \(N\) iterations update the parameters as: \(θ_i(n + 1) = θ_i(n) - a(n)
   g_i(n)\), where \(g_i(n)\) is an approximation of the gradient of the
objective function \(f(θ)\), with respect to \(θ_i\), given by
</p>
\begin{align}
g_i(n) = \frac{f(θ + c(n)Δ(n)) - f(θ - c(n)Δ(n))}{2 c(n)Δ_i(n)}.
\end{align}
<p>
Here \(Δ(n) = \{Δ_i(n)\}\) is a vector of random numbers sampled from a
Bernoulli (\(±1\)) distribution, with probability \(p\), and \(a(n)\), and
\(c(n)\) are step size sequences which are chosen satisfying some criteria.
</p></li>
</ol>

<p>
SPSA is implemented in <code>vqe/optimizers.py</code>.
</p>
</div>
</div>

<div id="outline-container-org2f3130d" class="outline-2">
<h2 id="org2f3130d">Simulation</h2>
<div class="outline-text-2" id="text-org2f3130d">
<p>
We will do these simulations with the <code>qasm_simulator</code> backend provided by
Qiskit, initially without noise. First we will demonstrate VQE with the single
layer RYRZ ansatz, and then with the single layer RX ansatz.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #51afef;">from</span> vqe.vqe <span style="color: #51afef;">import</span> energy
<span style="color: #51afef;">from</span> vqe.optimizers <span style="color: #51afef;">import</span> SPSA


<span style="color: #5B6268;"># </span><span style="color: #5B6268;">The expectation value of the Hamiltonian</span>
<span style="color: #51afef;">def</span> <span style="color: #c678dd;">parameterized_energy</span>(params, H, ansatz, **kwargs):
    <span style="color: #51afef;">return</span> energy(H, ansatz, params=params, **kwargs)


<span style="color: #5B6268;"># </span><span style="color: #5B6268;">Random number generator</span>
<span style="color: #dcaeea;">seed</span> = <span style="color: #da8548; font-weight: bold;">42</span>
<span style="color: #dcaeea;">rng</span> = np.random.default_rng(seed)

<span style="color: #5B6268;"># </span><span style="color: #5B6268;">Optimizer</span>
<span style="color: #dcaeea;">maxiter</span> = <span style="color: #da8548; font-weight: bold;">1000</span>
<span style="color: #dcaeea;">save_steps</span> = <span style="color: #da8548; font-weight: bold;">50</span>
<span style="color: #dcaeea;">a</span> = <span style="color: #da8548; font-weight: bold;">2</span> * np.pi * <span style="color: #da8548; font-weight: bold;">0.1</span>
<span style="color: #dcaeea;">c</span> = <span style="color: #da8548; font-weight: bold;">0.1</span>
<span style="color: #dcaeea;">A</span> = <span style="color: #da8548; font-weight: bold;">0.0001</span>
<span style="color: #dcaeea;">spsa</span> = SPSA(a=a, c=c, A=A)

<span style="color: #5B6268;"># </span><span style="color: #5B6268;">VQE with RYRZ ansatz</span>
<span style="color: #dcaeea;">reps</span> = <span style="color: #da8548; font-weight: bold;">1</span>
<span style="color: #dcaeea;">thetas_yz</span> = rng.uniform(<span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">2</span> * np.pi, size=(<span style="color: #da8548; font-weight: bold;">4</span> * (reps + <span style="color: #da8548; font-weight: bold;">1</span>)))
<span style="color: #dcaeea;">ryrz_ansatz</span> = RYRZAnsatz(reps=reps)

<span style="color: #dcaeea;">result_yz</span> = spsa.minimize(
    parameterized_energy,
    thetas_yz,
    maxiter=maxiter,
    save_steps=save_steps,
    seed=seed,
    H=H,
    ansatz=ryrz_ansatz,
)

<span style="color: #51afef;">print</span>(f<span style="color: #98be65;">"Lowest eigenvalue is {result_yz['fun']:.4f}."</span>)
</pre>
</div>

<pre class="example">
Lowest eigenvalue is -0.9990.
</pre>


<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #5B6268;"># </span><span style="color: #5B6268;">VQE with RX ansatz</span>
<span style="color: #dcaeea;">reps</span> = <span style="color: #da8548; font-weight: bold;">1</span>
<span style="color: #dcaeea;">thetas_x</span> = rng.uniform(<span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">2</span> * np.pi, size=reps)
<span style="color: #dcaeea;">rx_ansatz</span> = RXAnsatz(reps=reps)

<span style="color: #dcaeea;">result_x</span> = spsa.minimize(
    parameterized_energy,
    thetas_x,
    maxiter=maxiter,
    save_steps=save_steps,
    seed=seed,
    H=H,
    ansatz=rx_ansatz,
)

<span style="color: #51afef;">print</span>(f<span style="color: #98be65;">"Lowest eigenvalue is {result_x['fun']:.4f}."</span>)
</pre>
</div>

<pre class="example">
Lowest eigenvalue is -1.0000.
</pre>


<p>
Both the ansatzes effectively give \(-1\) as the minimum eigenvalue when running
on the simulator without noise. Let us now add noise to the simulation. For this
we will real noise data from the <code>ibmq_vigo</code> device using the data stored in
Qiskit Terra.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #51afef;">from</span> qiskit <span style="color: #51afef;">import</span> Aer
<span style="color: #51afef;">from</span> qiskit.test.mock <span style="color: #51afef;">import</span> FakeVigo
<span style="color: #51afef;">from</span> qiskit.providers.aer.noise <span style="color: #51afef;">import</span> NoiseModel

<span style="color: #5B6268;"># </span><span style="color: #5B6268;">Vigo noise model</span>
<span style="color: #dcaeea;">device_backend</span> = FakeVigo()
<span style="color: #dcaeea;">coupling_map</span> = device_backend.configuration().coupling_map
<span style="color: #dcaeea;">noise_model</span> = NoiseModel.from_backend(device_backend)
<span style="color: #dcaeea;">basis_gates</span> = noise_model.basis_gates

<span style="color: #5B6268;"># </span><span style="color: #5B6268;">BasicAer does not support noise, we need the simulator from Aer</span>
<span style="color: #dcaeea;">backend</span> = Aer.get_backend(<span style="color: #98be65;">"qasm_simulator"</span>)

<span style="color: #5B6268;"># </span><span style="color: #5B6268;">Noisy VQE with RYRZ ansatz</span>
<span style="color: #dcaeea;">result_yz_noisy</span> = spsa.minimize(
    parameterized_energy,
    thetas_yz,
    maxiter=maxiter,
    save_steps=save_steps,
    seed=seed,
    H=H,
    ansatz=ryrz_ansatz,
    backend=backend,
    noise_model=noise_model,
    coupling_map=coupling_map,
    basis_gates=basis_gates
)

<span style="color: #51afef;">print</span>(f<span style="color: #98be65;">"Lowest eigenvalue is {result_yz_noisy['fun']:.4f}."</span>)
</pre>
</div>

<pre class="example">
Lowest eigenvalue is -0.8760.
</pre>


<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #5B6268;"># </span><span style="color: #5B6268;">Noisy VQE with RX ansatz</span>
<span style="color: #dcaeea;">result_x_noisy</span> = spsa.minimize(
    parameterized_energy,
    thetas_x,
    maxiter=maxiter,
    save_steps=save_steps,
    seed=seed,
    H=H,
    ansatz=rx_ansatz,
    backend=backend,
    noise_model=noise_model,
    coupling_map=coupling_map,
    basis_gates=basis_gates
)

<span style="color: #51afef;">print</span>(f<span style="color: #98be65;">"Lowest eigenvalue is {result_x_noisy['fun']:.4f}."</span>)
</pre>
</div>

<pre class="example">
Lowest eigenvalue is -0.8584.
</pre>


<p>
With noise added to the system we no longer get the exact lowest eigenvalue of
the Hamiltonian. But we still come close to it.
</p>
</div>
</div>

<div id="outline-container-org6f8ada5" class="outline-2">
<h2 id="org6f8ada5">Visualization</h2>
<div class="outline-text-2" id="text-org6f8ada5">
<p>
We can see the progress of the optimization, which might give us some insights
into VQE.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #dcaeea;">iters</span> = np.arange(<span style="color: #da8548; font-weight: bold;">0</span>, maxiter + save_steps, save_steps)

<span style="color: #dcaeea;">fig</span>, <span style="color: #dcaeea;">ax</span> = plt.subplots(figsize=(<span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">8</span>))
ax.plot(iters, result_yz[<span style="color: #98be65;">"log"</span>][<span style="color: #98be65;">"fevals"</span>], color=<span style="color: #98be65;">"darkorange"</span>, linestyle=<span style="color: #98be65;">"solid"</span>, label=<span style="color: #98be65;">"RYRZ (noiseless)"</span>)
ax.plot(iters, result_yz_noisy[<span style="color: #98be65;">"log"</span>][<span style="color: #98be65;">"fevals"</span>], color=<span style="color: #98be65;">"darkorange"</span>, linestyle=<span style="color: #98be65;">"dashed"</span>, label=<span style="color: #98be65;">"RYRZ (noisy)"</span>)
ax.plot(iters, result_x[<span style="color: #98be65;">"log"</span>][<span style="color: #98be65;">"fevals"</span>], color=<span style="color: #98be65;">"dodgerblue"</span>, linestyle=<span style="color: #98be65;">"solid"</span>, label=<span style="color: #98be65;">"RX (noiseless)"</span>)
ax.plot(iters, result_x_noisy[<span style="color: #98be65;">"log"</span>][<span style="color: #98be65;">"fevals"</span>], color=<span style="color: #98be65;">"dodgerblue"</span>, linestyle=<span style="color: #98be65;">"dashed"</span>, label=<span style="color: #98be65;">"RX (noisy)"</span>)
ax.set_xlabel(<span style="color: #98be65;">"Iterations"</span>)
ax.set_ylabel(<span style="color: #98be65;">"Energy"</span>)
ax.legend()
fig.savefig(<span style="color: #98be65;">"static/images/rx_log.png"</span>, bbox_inches=<span style="color: #98be65;">"tight"</span>, dpi=<span style="color: #da8548; font-weight: bold;">90</span>)
plt.close()
</pre>
</div>


<div id="orgb409d7b" class="figure">
<p><img src="static/images/rx_log.png" alt="rx_log.png" />
</p>
</div>

<p>
Few observations that we can immediately make from this figure:
</p>
<ol class="org-ol">
<li>VQE converges pretty fast for the RX ansatz, both with and without
noise. About 200 SPSA iterations seem to be enough, instead of the 1000 that
we used.</li>
<li>The RYRZ ansatz takes longer to converge. Even though in this figure we see
that the noisy version converges earlier, albeit to a wrong value, than the
noiseless version. That is not always true. A different run is equally likely
to show the opposite. This is possibly due to the probabilistic nature of
SPSA. This also indicates the importance of the choice of the ansatz.</li>
<li>The noise is affecting the converged answers for both the ansatzes in the
same way. If we know what the noise is, we can possibly correct for it once
we reach convergence.</li>
</ol>
</div>
</div>

<div id="outline-container-org41708be" class="outline-2">
<h2 id="org41708be">Conclusion</h2>
<div class="outline-text-2" id="text-org41708be">
<p>
We demonstrated the VQE algorithm with a quantum simulator. We showed that it
gives the lowest eigenvalue on a noiseless device. On a noisy device, it does
not give the correct answer, but it goes quite close. Maybe further error
correction procedures can help with that.
</p>

<p>
Further explorations would naturally involve trying out other ansatz, and other
optimization methods. Automatic differentiation would greatly facilitate the use
of gradient based optimizers for VQE problems. Though SPSA did an excellent job
with this toy problem, it would be worthwhile to check if gradient based
optimizers give superior performance. Towards that end one could investigate how
to integrate existing automatic differentiation packages like JAX and Autograd
with quantum computing packages like Qiskit. The most important exploration
would be to try this on an actual quantum computer, with a more complicated
Hamiltonian to demonstrate the quantum advantage that VQE provides. In addition
one can also explore how to correct for noise on NISQ devices.
</p>

<p>
You can find the code for this at <a href="https://github.com/e-eight/vqe/">https://github.com/e-eight/vqe/</a>.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
Peruzzo, A., McClean, J., Shadbolt, P. <i>et al.</i>, A variational eigenvalue
solver on a photonic quantum processor. Nat Commun 5, 4213
(2014). <a href="https://www.nature.com/articles/ncomms5213">https://doi.org/10.1038/ncomms5213</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
Kandala, A., Mezzacapo, A., Temme, K. <i>et al.</i>, Hardware-efficient
variational quantum eigensolver for small molecules and quantum magnets. Nature
549, 242–246 (2017). <a href="https://doi.org/10.1038/nature23879">https://doi.org/10.1038/nature23879</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
Dumitrescu, E. F. <i>et al.</i> Cloud Quantum Computing of an Atomic Nucleus.”
Physical Review Letters 120.21 (2018). <a href="https://arxiv.org/abs/1801.03897">https://arxiv.org/abs/1801.03897</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4">4</a></sup> <div class="footpara"><p class="footpara">
To see why the trace is necessary think of the matrix as a one
dimensional vector:
</p>
\begin{align}
\begin{bmatrix}
a & b \\
c & d
\end{bmatrix}
→
\begin{bmatrix}
a \\
b \\
c \\
d
\end{bmatrix}.
\end{align}
<p class="footpara">
This inner product \((A, B) = \mathrm{Tr}(A^† B)\) is known as the Hilbert-Schmidt
inner product which turns the vector space of those matrices in to a Hilbert
space. Some details can be found in chapter 2 of <a href="https://dl.acm.org/doi/book/10.5555/1972505">Nielsen &amp; Chuang</a>.
</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5">5</a></sup> <div class="footpara"><p class="footpara">
For more details on making measurements with tensor products of Pauli
operators check out this excellent <a href="https://quantumcomputing.stackexchange.com/a/13675/12785">answer</a> by Davit Kachatryan and
<a href="https://docs.microsoft.com/en-us/quantum/concepts/pauli-measurements">Pauli Measurements</a> by Microsoft Quantum.
</p></div></div>

<div class="footdef"><sup><a id="fn.6" class="footnum" href="#fnr.6">6</a></sup> <div class="footpara"><p class="footpara">
Check <a href="https://www.jhuapl.edu/SPSA/">https://www.jhuapl.edu/SPSA/</a> and
<a href="https://www.csa.iisc.ac.in/~shalabh/book.html">https://www.csa.iisc.ac.in/~shalabh/book.html</a> for details on SPSA.
</p></div></div>


</div>
</div></div>
</body>
</html>
